* Keymap
** Requirements :noexport:
#+begin_src emacs-lisp
  ;;; the-keymap.el --- Non-color-theme appearance tweaks

  (require 'the-package)
  (require 'the-custom)
  (require 'the-bind-key)
  (require 'the-hydra)
  (require 'the-libraries)
  (require 'the-modeline)
#+end_src

** =which-key=

Emacs is a big beast, and =which-key= makes it much easier to deal
with.

*** Settings
:PROPERTIES:
:header-args: :tangle no
:END:

**** Sort order
Sort =which-key= suggestions alphabetically.

#+NAME: wk-sort
#+begin_src emacs-lisp
  (setq which-key-sort-order 'which-key-key-order-alpha)
#+end_src

*** =use-package= declaration
#+begin_src emacs-lisp
  (use-package which-key
    :init
    <<wk-sort>>
    :bind* (("M-T ?" . which-key-show-top-level))
    :config
    (which-key-mode)
    (which-key-add-key-based-replacements
      "M-T ?" "top level bindings")
    :delight (which-key-mode  ""))
#+end_src

** Discoverability

Some major modes have default bindings, and digging those up is much
easier with =discover-my-major=.

#+begin_src emacs-lisp
  (use-package discover-my-major
    :bind (("C-h C-m" . discover-my-major)
           ("C-h M-T" . discover-my-mode)))
#+end_src

* Modalka

Evil's not enough effort, apparently, so I'm building my own modal
bindings with =modalka=, a great framework for custom modal editing.
This isn't to everyone's tastes, so it can be turned off by
customizing a variable.

#+begin_src emacs-lisp
  (defcustom the-modalka-activation t
    "If non-nil, use modalka for modal editing"
    :type '(boolean)
    :group 'the)
#+end_src

#+begin_src emacs-lisp
  (when the-modalka-activation
    (use-package modalka
      :demand t
      :bind* (("C-z" . modalka-mode))
      :init
      (setq modalka-cursor-type 'box)
      :config
      (bind-key "<escape>" #'modalka-mode)
      (modalka-define-kbd "<escape>" "C-g")
      (add-hook 'text-mode-hook #'modalka-mode)
      (add-hook 'prog-mode-hook #'modalka-mode)
      (setq-default cursor-type '(bar . 1))
      (setq modalka-cursor-type 'box)
      :delight (modalka-mode "Âµ")))
#+end_src

** Helper functions

We'll use org tables to document our bindings, and because org is cool
we can also use the tables to create those bindings. For that, we need
a couple of helper functions.

#+begin_src emacs-lisp
  (defun the-which-key-suggestion-builder (mapping)
    (which-key-add-key-based-replacements (-second-item mapping) (-first-item mapping)))

  (defun the-which-key-suggestion-generator (data)
    (-each data 'the-which-key-suggestion-builder))

  (defun the-modalka-binding-builder (mapping)
    (if (s-present? (-last-item mapping))
        (modalka-define-kbd (-second-item mapping) (-last-item mapping))))

  (defun the-modalka-binding-generator (data)
    (when the-modalka-activation
      (-each data 'the-modalka-binding-builder)))
#+end_src


** Prefix keys

We're gonna end up with a lot of bindings, so we'll set up some
prefixes for classes of bindings.

#+NAME: prefixes
| purpose          | prefix  |
|------------------+---------|
| leader key       | SPC     |
| help prefix      | SPC h   |
| ex key           | :       |
| THE prefix       | M-T     |
| movement prefix  | M-T m   |
| extended prefix  | M-T :   |
| send code prefix | M-T s   |
| user prefix      | M-T SPC |
| global prefix    | M-T g   |
| org prefix       | M-T o   |
| "around" prefix  | M-T a   |
| "inside" prefix  | M-T i   |
| "prev" prefix    | M-T [   |
| "next" prefix    | M-T ]   |

#+NAME: generate prefix key which-key suggestions
#+begin_src emacs-lisp :exports code :var data=prefixes[1:-1]
  (the-which-key-suggestion-generator data)
#+end_src

** Org Bindings

#+NAME: org-bindings
| purpose                 | modalka   | emacs       |
|-------------------------+-----------+-------------|
| org agenda              | SPC o a   | C-c a       |
| org capture             | SPC o c   | C-c c       |
| org store link          | SPC o l   | C-c l       |
| org insert link         | SPC o L   | C-c C-l     |
| org iswitchb            | SPC o B   | C-c b       |
| org clock in            | SPC o C i | C-c C-x TAB |
| org clock out           | SPC o C o | C-c C-x C-o |
| org do something useful | SPC o RET | C-c C-c     |
| org journal new entry   | SPC o j n | C-c C-j     |
| org forward             | SPC o f   | M-}         |
| org backward            | SPC o b   | M-{         |

#+NAME: generate org bindings and suggestions
#+begin_src emacs-lisp :exports none :var data=org-bindings[1:-1]
  (the-which-key-suggestion-generator data)
  (the-modalka-binding-generator data)
#+end_src

** Vim-like bindings

We'll set up some convenient bindings for a more vim-like experience.

#+NAME: vim
| function                            | modalka | emacs   |
|-------------------------------------+---------+---------|
| leave modalka                       | i       | C-z     |
| left                                | h       | C-b     |
| down                                | j       | C-n     |
| up                                  | k       | C-p     |
| right                               | l       | C-f     |
| forward word                        | w       | M-f     |
| backward word                       | b       | M-b     |
| smart next item                     | n       | M-n     |
| smart prev item                     | N       | M-p     |
| previous paragraph/org element      | {       | M-{     |
| next paragraph/org element          | }       | M-}     |
| beginning of line                   | "0"     | C-a     |
| end of line                         | $       | C-e     |
| end of buffer                       | G       | M->     |
| beginning of buffer                 | g g     | M-<     |
| yank (vim)/kill (emacs)             | y       | M-w     |
| paste (vim)/yank (emacs)            | p       | C-y     |
| yank pop (paste history)            | P       | M-y     |
| delete char                         | x       | C-d     |
| kill line                           | D       | C-k     |
| re-center screen                    | z       | C-l     |
| shell command (async)               | !       | M-&     |
| scroll left                         | H       | C-x <   |
| scroll up                           | J       | C-v     |
| scroll down                         | K       | M-v     |
| scroll right                        | L       | C-x >   |
| backward sentence                   | (       | M-a     |
| forward sentence                    | )       | M-e     |
| search                              | /       | C-s     |
| quit (minibuffer, etc)              | E       | C-g     |
| go to line                          | g l     | M-g g   |
| record macro                        | q       | C-x (   |
| end macro                           | Q       | C-x )   |
| set mark (visual mode)              | v       | C-SPC   |
| rectangle edit mode (better visual) | V       | M-T V   |
| indent region                       | =       | C-M-\   |
| set bookmark                        | +       | C-x r m |
| jump to bookmark                    | '       | C-x r b |
| compile/lots of other stuff         | \\      | C-c C-c |

#+NAME: generate vim bindings and suggestions
#+begin_src emacs-lisp :exports code :var data=vim[1:-1]
  (the-which-key-suggestion-generator data)
  (the-modalka-binding-generator data)
#+end_src

*** Hydras

**** Rectangle Edit Mode
This is basically an improved and more interactive version of the
standard visual mode from Vim.

#+begin_src emacs-lisp
  (defhydra the-hydra-rectangle (:pre (rectangle-mark-mode 1)
                                      :color pink
                                      :hint nil)
    "
   _p_: paste   _r_: replace  _I_: insert
   _y_: copy    _o_: open     _V_: reset
   _d_: kill    _n_: number   _q_: quit
  "
    ("h" backward-char nil)
    ("l" forward-char nil)
    ("k" previous-line nil)
    ("j" next-line nil)
    ("y" copy-rectangle-as-kill)
    ("d" kill-rectangle)
    ("x" clear-rectangle)
    ("o" open-rectangle)
    ("p" yank-rectangle)
    ("r" string-rectangle)
    ("n" rectangle-number-lines)
    ("I" string-insert-rectangle)
    ("V" (if (region-active-p)
             (deactivate-mark)
           (rectangle-mark-mode 1)) nil)
    ("q" keyboard-quit :color blue))

  (bind-keys*
    ("M-T V" . the-hydra-rectangle/body))
#+end_src

** Help bindings

There's a lot of stuff to dig around, so when all else fails, =SPC h=
and figure out what's out there.

#+NAME: help
| function            | modalka | emacs   |
|---------------------+---------+---------|
| describe function   | SPC h f | C-h f   |
| describe variable   | SPC h v | C-h v   |
| describe key        | SPC h k | C-h k   |
| describe bindings   | SPC ?   | C-h b   |
| major mode bindings | SPC h m | C-h C-m |
| minor mode bindings | SPC h M | C-h M-T |

#+NAME: generate help bindings and suggestions
#+begin_src emacs-lisp :exports none :var data=help[1:-1]
  (the-which-key-suggestion-generator data)
  (the-modalka-binding-generator data)
#+end_src

#+NAME: movement
| function        | modalka | emacs |
|-----------------+---------+-------|
| movement prefix |         |       |

#+NAME: ex
| function             | modalka | emacs   |
|----------------------+---------+---------|
| ex key               | :       |         |
| find file            | : e     | C-x C-f |
| insert file          | : r     | C-x i   |


#+NAME: generate ex key which-key suggestions and bindings
#+begin_src emacs-lisp :exports none yes :var data=ex[1:-1]
  (the-which-key-suggestion-generator data)
  (the-modalka-binding-generator data)
#+end_src

** Provides :noexport:
#+begin_src emacs-lisp
  (provide 'keymap)
#+end_src
